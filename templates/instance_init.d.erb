#!/bin/sh
# This file is automatically generated by puppet. Changes will be lost.
#
# Originally sourced from Debian's mysql 5.5 init.d script, except tracking the
# pidfile rather than using debian's root-equivalent user.
#
### BEGIN INIT INFO
# Provides:          mysql-<%=@instance%>
# Required-Start:    $local_fs $remote_fs $syslog
# Required-Stop:     $local_fs $remote_fs $syslog
# Should-Start:      $network $time
# Should-Stop:       $network $time
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Start and stop the mysql database server daemon for <%=@instance%>
# Description:       Controls the main MySQL database server daemon "mysqld"
#                    and its wrapper script "mysqld_safe" for the instance <%=@instance%>.
### END INIT INFO
#
set -e
set -u
${DEBIAN_SCRIPT_DEBUG:+ set -v -x}

basedir="<%=@basedir%>"
datadir="<%=@datadir%>"
sockdir="<%=@sockdir%>"
mysqld_user="<%=@daemon_user%>"
bindir="$basedir"/bin
mycnf="$datadir"/my.cnf
mysqld="$bindir"/mysqld
mysqld_safe="$bindir"/mysqld_safe
test -x "$mysqld_safe" || exit 0

# priority can be overriden and "-s" adds output to stderr
ERR_LOGGER="logger -p daemon.err -t $0 -i"
. /lib/lsb/init-functions

## Fetch a particular option from mysql's invocation.
#
# Usage: void mysqld_get_param option
mysqld_get_param() {
	"$mysqld" --defaults-file="$mycnf" --print-defaults \
		| tr " " "\n" \
		| grep -- "--$1" \
		| tail -n 1 \
		| cut -d= -f2
}

pidfile=`mysqld_get_param pid-file`
pid=`cat $pidfile 2>/dev/null || true`

cd "$basedir"
umask 077
export HOME=$datadir

## Do some sanity checks before even trying to start mysqld.
sanity_checks() {
  # check for config file
  if [ ! -r "$mycnf" ]; then
    log_warning_msg "$0: WARNING: "$mycnf" cannot be read."
    echo                "WARNING: "$mycnf" cannot be read." | $ERR_LOGGER
  fi

  # check for diskspace shortage
  if LC_ALL=C BLOCKSIZE= df --portability $datadir/. | tail -n 1 | awk '{ exit ($4>4096) }'; then
    log_failure_msg "$0: ERROR: The partition with $datadir is too full!"
    echo                "ERROR: The partition with $datadir is too full!" | $ERR_LOGGER
    exit 1
  fi
}

## Checks if there is a server running and if so if it is accessible.
#
# check_alive insists on a pingable server
# check_dead also fails if there is a lost mysqld in the process list
#
# Usage: boolean mysqld_status [check_alive|check_dead] [warn|nowarn]
mysqld_status () {
    ps_alive=0
    if [ -f "$pidfile" ] && ps `cat $pidfile` >/dev/null 2>&1; then ps_alive=1; fi
    
    if [ "$1" = "check_alive" -a $ps_alive = 1 ] ||
       [ "$1" = "check_dead"  -a $ps_alive = 0 ]; then
	return 0 # EXIT_SUCCESS
    else
  	if [ "$2" = "warn" ]; then
  	    echo -e "$ps_alive processes alive" | $ERR_LOGGER -p daemon.debug
	fi
  	return 1 # EXIT_FAILURE
    fi
}

#
# main()
#

case "${1:-''}" in
  'start')
	sanity_checks;
	# Start daemon
	log_daemon_msg "Starting MySQL/<%=@instance%> database server" "mysqld"
	if mysqld_status check_alive nowarn; then
	   log_progress_msg "already running"
	   log_end_msg 0
	else
	    # Could be removed during boot
	    test -e "$sockdir" || install -m 755 -o "$mysqld_user" -g root -d "$sockdir"
	    test -e /var/run/mysqld || install -m 1777 -o root -g root -d /var/run/mysqld

	    # Start MySQL! 
  	    "$mysqld_safe" --defaults-file="$mycnf" > /dev/null 2>&1 &

	    # 6s was reported in #352070 to be too few when using ndbcluster
	    for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14; do
                sleep 1
	        if mysqld_status check_alive nowarn ; then break; fi
		log_progress_msg "."
	    done
	    if mysqld_status check_alive warn; then
                log_end_msg 0
	    else
	        log_end_msg 1
		log_failure_msg "Please take a look at the syslog"
	    fi
	fi
	;;

  'stop')
	log_daemon_msg "Stopping MySQL/<%=@instance%> database server" "mysqld"
	if ! mysqld_status check_dead nowarn; then
	  kill $pid
	  server_down=
	  for i in 1 2 3 4 5 6 7 8 9 10; do
	    sleep 1
	    if mysqld_status check_dead nowarn; then server_down=1; break; fi
	  done
        fi

        if ! mysqld_status check_dead warn; then
	  log_end_msg 1
	  log_failure_msg "Please stop MySQL/<%=@instance%> manually!"
	  exit -1
	else
	  log_end_msg 0
        fi
	;;

  'restart')
	set +e; $SELF stop; set -e
	$SELF start 
	;;

  'reload'|'force-reload')
  	log_daemon_msg "Reloading MySQL/<%=@instance%> database server" "mysqld"
	kill -HUP $pid
	touch "$pidfile"
	log_end_msg 0
	;;

  'status')
	if mysqld_status check_alive nowarn; then
	  log_action_msg "MySQL/<%=@instance%> is running ($pid)"
	else
	  log_action_msg "MySQL/<%=@instance%> is stopped."
	  exit 3
	fi
  	;;

  *)
	echo "Usage: $SELF start|stop|restart|reload|force-reload|status"
	exit 1
	;;
esac

